name: Deploy

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options: [production, staging]
      image_tag:
        description: 'Docker image tag (leave empty for latest)'
        required: false
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    timeout-minutes: 30
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch'

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}

      - uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VM_SSH_PRIVATE_KEY }}

      - run: ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts

      - name: Set image tag
        id: tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            TAG="${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.ref_type }}" == "tag" ]; then
            TAG="${{ github.ref_name }}"
          else
            TAG="latest"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Copy docker-compose file to server
        run: |
          scp docker-compose.prod.yml ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}:/opt/go-backend-api/docker-compose.prod.yml

      - name: Deploy
        env:
          API_PORT: ${{ secrets.API_PORT || '8080' }}
          IMAGE: ${{ secrets.DOCKER_USERNAME }}/go-backend-api:${{ steps.tag.outputs.tag }}
        run: |
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} bash << EOF
            set -e
            cd /opt/go-backend-api
            
            if [ ! -f .env.production ]; then
              echo "Error: .env.production not found!"
              exit 1
            fi
            
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            
            # Only pull if image doesn't exist locally or if forced
            if ! docker image inspect $IMAGE >/dev/null 2>&1; then
              docker pull $IMAGE || docker pull ${{ secrets.DOCKER_USERNAME }}/go-backend-api:latest
            fi
            
            docker compose -f docker-compose.prod.yml down || true
            
            sed -i.tmp "s|^    build:.*|    image: $IMAGE|" docker-compose.prod.yml
            sed -i.tmp '/^      context:/d; /^      dockerfile:/d; /^      args:/,/^        GO_VERSION:/d' docker-compose.prod.yml
            rm -f docker-compose.prod.yml.tmp
            
            docker compose -f docker-compose.prod.yml up -d
            
            HEALTHY=false
            for i in {1..20}; do
              if curl -f http://localhost:${API_PORT}/api/v1/health > /dev/null 2>&1; then
                echo "✅ Service is healthy!"
                HEALTHY=true
                break
              fi
              sleep 2
            done
            
            if [ "$HEALTHY" != "true" ]; then
              echo "❌ Health check failed"
              docker compose -f docker-compose.prod.yml logs
              exit 1
            fi
          EOF

      - name: Verify
        env:
          API_PORT: ${{ secrets.API_PORT || '8080' }}
        run: |
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} << EOF
            docker compose -f /opt/go-backend-api/docker-compose.prod.yml ps
            curl -f http://localhost:${API_PORT}/api/v1/health
          EOF
